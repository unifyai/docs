{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "collapsed": false,
        "pycharm": {
          "name": "#%% md\n"
        },
        "id": "bLWUYAEhkbRR"
      },
      "source": [
        "---\n",
        "file: temp_demos/end_to_end_training_pipeline_in_ivy.ipynb\n",
        "---"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "collapsed": false,
        "pycharm": {
          "name": "#%% md\n"
        },
        "id": "Ckul4XOmkbRT"
      },
      "source": [
        "# End-to-End Training Pipeline in Ivy"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "dXnE1vqdkbRU"
      },
      "source": [
        "ToDo: description"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "collapsed": false,
        "pycharm": {
          "name": "#%% md\n"
        },
        "id": "IqVm_caAkbRU"
      },
      "source": [
        "::::: {#colab-button}\n",
        "[![Open in Colab]({{< var remote_badge.colab >}})](https://colab.research.google.com/github/unifyai/demos/blob/main/{{< meta file >}})\n",
        "[![GitHub]({{< var remote_badge.github >}})](https://github.com/unifyai/demos/blob/main/{{< meta file >}})\n",
        ":::::"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 1,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 902
        },
        "id": "viDG7dwgD4Fd",
        "outputId": "453c3af5-e9d5-4360-8d3e-689d104998b3",
        "pycharm": {
          "name": "#%%\n"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Looking in indexes: https://pypi.org/simple, https://us-python.pkg.dev/colab-wheels/public/simple/\n",
            "Collecting git+https://github.com/unifyai/ivy.git@master\n",
            "  Cloning https://github.com/unifyai/ivy.git (to revision master) to /tmp/pip-req-build-_3r2_73j\n",
            "  Running command git clone --filter=blob:none --quiet https://github.com/unifyai/ivy.git /tmp/pip-req-build-_3r2_73j\n",
            "  Resolved https://github.com/unifyai/ivy.git to commit 0edf8c1e8ea835f4c456bdf89737d89032f50b5a\n",
            "  Running command git submodule update --init --recursive -q\n",
            "  Preparing metadata (setup.py) ... \u001b[?25l\u001b[?25hdone\n",
            "Requirement already satisfied: numpy in /usr/local/lib/python3.9/dist-packages (from ivy-core==1.1.9) (1.22.4)\n",
            "Collecting einops==0.4.1\n",
            "  Downloading einops-0.4.1-py3-none-any.whl (28 kB)\n",
            "Collecting psutil==5.9.1\n",
            "  Downloading psutil-5.9.1-cp39-cp39-manylinux_2_12_x86_64.manylinux2010_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl (281 kB)\n",
            "\u001b[2K     \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m281.1/281.1 KB\u001b[0m \u001b[31m10.9 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hCollecting termcolor==1.1.0\n",
            "  Downloading termcolor-1.1.0.tar.gz (3.9 kB)\n",
            "  Preparing metadata (setup.py) ... \u001b[?25l\u001b[?25hdone\n",
            "Collecting colorama==0.4.5\n",
            "  Downloading colorama-0.4.5-py2.py3-none-any.whl (16 kB)\n",
            "Collecting packaging==21.3\n",
            "  Downloading packaging-21.3-py3-none-any.whl (40 kB)\n",
            "\u001b[2K     \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m40.8/40.8 KB\u001b[0m \u001b[31m4.7 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hCollecting nvidia-ml-py<=11.495.46\n",
            "  Downloading nvidia_ml_py-11.495.46-py3-none-any.whl (25 kB)\n",
            "Requirement already satisfied: pyparsing!=3.0.5,>=2.0.2 in /usr/local/lib/python3.9/dist-packages (from packaging==21.3->ivy-core==1.1.9) (3.0.9)\n",
            "Building wheels for collected packages: ivy-core, termcolor\n",
            "  Building wheel for ivy-core (setup.py) ... \u001b[?25l\u001b[?25hdone\n",
            "  Created wheel for ivy-core: filename=ivy_core-1.1.9-py3-none-any.whl size=1297564 sha256=05fcafac1e19fec835a9ac61270b3ac6039a5095f6b0f9fde20bacc2a5abba45\n",
            "  Stored in directory: /tmp/pip-ephem-wheel-cache-le3bu3_v/wheels/07/46/2e/ae2d7c5ce8708e605368a33e08d57d1de8e107e3db157c3063\n",
            "  Building wheel for termcolor (setup.py) ... \u001b[?25l\u001b[?25hdone\n",
            "  Created wheel for termcolor: filename=termcolor-1.1.0-py3-none-any.whl size=4845 sha256=cc6508f5d7e25538c5df5fdae52a41d2bf17b9a517aedd125cfca913bb5b259b\n",
            "  Stored in directory: /root/.cache/pip/wheels/b6/0d/90/0d1bbd99855f99cb2f6c2e5ff96f8023fad8ec367695f7d72d\n",
            "Successfully built ivy-core termcolor\n",
            "Installing collected packages: termcolor, nvidia-ml-py, einops, psutil, packaging, colorama, ivy-core\n",
            "  Attempting uninstall: termcolor\n",
            "    Found existing installation: termcolor 2.2.0\n",
            "    Uninstalling termcolor-2.2.0:\n",
            "      Successfully uninstalled termcolor-2.2.0\n",
            "  Attempting uninstall: psutil\n",
            "    Found existing installation: psutil 5.9.4\n",
            "    Uninstalling psutil-5.9.4:\n",
            "      Successfully uninstalled psutil-5.9.4\n",
            "  Attempting uninstall: packaging\n",
            "    Found existing installation: packaging 23.0\n",
            "    Uninstalling packaging-23.0:\n",
            "      Successfully uninstalled packaging-23.0\n",
            "Successfully installed colorama-0.4.5 einops-0.4.1 ivy-core-1.1.9 nvidia-ml-py-11.495.46 packaging-21.3 psutil-5.9.1 termcolor-1.1.0\n"
          ]
        },
        {
          "output_type": "display_data",
          "data": {
            "application/vnd.colab-display-data+json": {
              "pip_warning": {
                "packages": [
                  "packaging",
                  "psutil"
                ]
              }
            }
          },
          "metadata": {}
        }
      ],
      "source": [
        "# install the latest Ivy version for this purpose\n",
        "!pip install git+https://github.com/unifyai/ivy.git@master"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "collapsed": false,
        "pycharm": {
          "name": "#%% md\n"
        },
        "id": "1zKySH_KkbRV"
      },
      "source": [
        "# Importing libraries\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 1,
      "metadata": {
        "id": "ttwcL6WSIRZH",
        "pycharm": {
          "name": "#%%\n"
        }
      },
      "outputs": [],
      "source": [
        "# third party libraries\n",
        "import ivy\n",
        "\n",
        "# built-in libraries\n",
        "import os\n",
        "import random\n",
        "import csv\n",
        "from tqdm import tqdm\n",
        "import matplotlib.pyplot as plt\n",
        "import cv2\n",
        "from PIL import Image\n",
        "import numpy as np\n",
        "import pandas as pd"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "from google.colab import drive\n",
        "drive.mount('/content/drive')"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "9P-LMZ8ck8Ue",
        "outputId": "da26f882-3841-4de7-aa60-fc57aebe43d8"
      },
      "execution_count": 3,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Mounted at /content/drive\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "pycharm": {
          "name": "#%%\n"
        },
        "id": "N0kLtV0VkbRW"
      },
      "outputs": [],
      "source": [
        "!mkdir /content/drive/MyDrive/Ivy/\n",
        "os.chdir('/content/drive/MyDrive/Ivy')"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "vsaBQt2LfYKA",
        "pycharm": {
          "name": "#%% md\n"
        }
      },
      "source": [
        "# Let's build the pipeline with a Tensorflow backend\n",
        "\n",
        "One can experiment with any other backend as well. Just add the following line at the start with the string name to be the framework you want. \n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 12,
      "metadata": {
        "id": "yLmXZO5NHmGR"
      },
      "outputs": [],
      "source": [
        "ivy.set_backend(\"tensorflow\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "_sZBpS1jfKkt",
        "pycharm": {
          "name": "#%% md\n"
        }
      },
      "source": [
        "# We are using MNIST dataset for this Tutorial\n",
        "\n",
        "Now we will download the MNIST dataset from Kaggle using its API. More details in this [medium](https://medium.com/swlh/image-classifcation-with-google-colab-183e95bfc439#:~:text=Download%20datasets%20directly%20to%20colab%20using%20kaggle%20API.&text=After%20uploading%20the%20JSON%20file,store%20it%20into%20data%20frames.&text=After%20this%2C%20additional%20data%20frames,images%20to%20train%20the%20model) article."
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "!mkdir /root/.kaggle"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "_bIIqcp9lx32",
        "outputId": "f36a0c91-5216-4b32-c89a-efcd32b6b9d7"
      },
      "execution_count": 15,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "mkdir: cannot create directory ‘/root/.kaggle’: File exists\n"
          ]
        }
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "Insert the `kaggle.json` file in the `/root/.kaggle` folder. You can download the file here `https://www.kaggle.com/{your_kaggle_username}/account` by clicking on `Create New API Token`"
      ],
      "metadata": {
        "id": "FUjnnhsFu-N2"
      }
    },
    {
      "cell_type": "code",
      "source": [
        "!kaggle competitions download -c digit-recognizer \n",
        "!unzip digit-recognizer.zip"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "39bYlmgRlhiu",
        "outputId": "a0ab5630-79eb-43bf-b72b-5b0a9a39c70e"
      },
      "execution_count": 18,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Warning: Your Kaggle API key is readable by other users on this system! To fix this, you can run 'chmod 600 /root/.kaggle/kaggle.json'\n",
            "digit-recognizer.zip: Skipping, found more recently modified local copy (use --force to force download)\n",
            "Archive:  digit-recognizer.zip\n",
            "  inflating: sample_submission.csv   \n",
            "  inflating: test.csv                \n",
            "  inflating: train.csv               \n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "#Import pandas and read training and testing data in data frames\n",
        "import pandas as pd \n",
        "train = pd.read_csv(\"train.csv\")\n",
        "test = pd.read_csv(\"test.csv\")"
      ],
      "metadata": {
        "id": "1Yel8hW5nIsr"
      },
      "execution_count": 19,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "# Set the PATH string that will be used to save the dataset in your Google Drive folder, it will be used later to load the dataset\n",
        "PATH = '/content/drive/My Drive/mnist'"
      ],
      "metadata": {
        "id": "3iEqK1AbwB3k"
      },
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "#Create a data frame to store labels, another without labels, df with values only, test value df and a path variable to set location of where to store images\n",
        "label_df = train['label']\n",
        "mod_train = train.drop(columns= 'label')\n",
        "data_values = mod_train.values\n",
        "test_data_values = test.values"
      ],
      "metadata": {
        "id": "Y9wWLlRTnYd2"
      },
      "execution_count": 43,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "for i in range(0, len(data_values)):\n",
        "    #read the correct label\n",
        "    correct_label = label_df[i]\n",
        "\n",
        "    #split the data into training and validation sets\n",
        "    if np.random.rand() < 0.8:\n",
        "        folder = '/train/'\n",
        "        train_path = f'{PATH}' + '/train/' + str(correct_label)\n",
        "        if not os.path.exists(train_path):\n",
        "          os.makedirs(train_path)\n",
        "    else:\n",
        "        folder = '/valid/'\n",
        "        valid_path = f'{PATH}' + '/valid/' + str(correct_label)\n",
        "        if not os.path.exists(valid_path):\n",
        "          os.makedirs(valid_path)\n",
        "    img = data_values[i][:]\n",
        "    #reshape into 28x28 pic\n",
        "    img = img.reshape(28,28)\n",
        "    #we need three channels into the picture\n",
        "    img = np.stack((img,)*3,axis = -1)\n",
        "    #change the data type to int8\n",
        "    img = np.uint8(img)\n",
        "    #create PIL Image\n",
        "    new_img = Image.fromarray(img)\n",
        "    #save the .jpg into correct folder\n",
        "    new_img.save(f'{PATH}' + folder + str(correct_label) + '/' + str(i) + '.jpg', 'JPEG')"
      ],
      "metadata": {
        "id": "si0Km1h2pacY"
      },
      "execution_count": 44,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "7VoBuoqjQqQy"
      },
      "source": [
        "# Temporary Dataset and Dynamic loader\n",
        "\n",
        "Since we don't have the builder ready just yet, we will create three functions which help in generating the dataset, randomizing, and batchwise loading at training time. \n",
        "\n",
        "**Note** -  We're only using a small subset of the entire dataset for the purpose of this demo. Same goes for the number of `epochs` we train the model for."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "l4dVyGp-e6km"
      },
      "source": [
        "Let's set a global seed for randomized operations"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 20,
      "metadata": {
        "id": "HE8evnQCeTuX"
      },
      "outputs": [],
      "source": [
        "ivy.seed(seed_value = 0)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 65,
      "metadata": {
        "id": "Gq8IM3-AUH2n"
      },
      "outputs": [],
      "source": [
        "def randomize_dataset(images, classes):\n",
        "    data = list(zip(images, classes))\n",
        "    random.shuffle(data)\n",
        "    images, classes = zip(*data)\n",
        "    return list(images), list(classes)\n",
        "\n",
        " \n",
        "def create_dataset(folder, num_examples_per_class = 100):\n",
        "    img_array = []\n",
        "    class_name = []\n",
        "    for dir in os.listdir(folder):\n",
        "        for i, file in enumerate(os.listdir(os.path.join(folder, dir))):\n",
        "            if i >= num_examples_per_class:\n",
        "                continue\n",
        "            img_path = os.path.join(folder, dir, file)\n",
        "            image = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)\n",
        "            image = ivy.array(image).astype('float32').expand_dims()\n",
        "            image /= 255\n",
        "            img_array.append(image) \n",
        "            class_name.append(dir)\n",
        "    \n",
        "    return randomize_dataset(img_array, class_name)\n",
        "\n",
        "\n",
        "def generate_batches(images, classes, dataset_size, batch_size = 32):\n",
        "    targets={k: v for v, k in enumerate(np.unique(classes))}\n",
        "    y_train= [targets[classes[i]] for i in range(len(classes))]\n",
        "    if batch_size > dataset_size:\n",
        "        raise ivy.utils.exceptions.IvyError('Use a smaller batch size')\n",
        "    for idx in range(0, dataset_size, batch_size):\n",
        "        yield ivy.stack(images[idx:min(idx+batch_size, dataset_size)]), ivy.array(y_train[idx:min(idx+batch_size, dataset_size)])\n",
        "\n",
        "\n",
        "#choosing 1000 examples per class for this demo\n",
        "images, classes = create_dataset(PATH + '/train',num_examples_per_class = 1000)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 66,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "dX4xW6nsxvj6",
        "outputId": "1be16a0c-1d8b-4e91-cc72-a0684c4d7045"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Number of Training Examples is -: 10000\n"
          ]
        }
      ],
      "source": [
        "print(f'Number of Training Examples is -: {len(images)}')"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 47,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "-gFZs6eAVYls",
        "outputId": "8566bc42-f3d6-4909-a8a5-5f6a8f3e9b8b"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Class labels -: {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}\n"
          ]
        }
      ],
      "source": [
        "targets = {k: v for v, k in enumerate(np.unique(classes))}\n",
        "print(f\"Class labels -: {targets}\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 48,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "bREEiiUu415W",
        "outputId": "75455c27-5d7e-460d-efc5-11d0dfdd4b8a"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Data is of the form -: (32, 1, 28, 28) (NCHW)\n",
            "\n",
            "32 ivy.array([2, 6, 8, 8, 3, 6, 0, 3, 6, 4, 1, 5, 8, 3, 8, 7, 4, 7, 1, 0, 0, 7,\n",
            "       9, 8, 2, 0, 2, 8, 8, 9, 1, 2], dev=gpu:0)\n"
          ]
        }
      ],
      "source": [
        "x_batch_instance, y = next(iter(generate_batches(images, classes, len(images))))\n",
        "print(f\"Data is of the form -: {x_batch_instance.shape} (NCHW)\\n\")\n",
        "print(y.shape[0], y)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "k0MFYmtCgc-V"
      },
      "source": [
        "Intialising some training parameters"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 49,
      "metadata": {
        "id": "k0Yim1MPZ1RK"
      },
      "outputs": [],
      "source": [
        "optimizer= ivy.Adam(1e-4)\n",
        "batch_size = 64 \n",
        "num_epochs = 20\n",
        "num_classes = 10"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "mGAcRGmUgjDn",
        "pycharm": {
          "name": "#%% md\n"
        }
      },
      "source": [
        "# Defining the Ivy Network\n",
        "\n",
        "We inherit from the `ivy.Module` class for creation of networks. This helps us with the forward pass and computation of the gradients. Note that some keyword arguments below are user-defined, and are purely for the purpose of building this model. You can find more information about the `init` method inside the docs."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 50,
      "metadata": {
        "id": "HrDmq06pfqQk"
      },
      "outputs": [],
      "source": [
        "class IvyNet(ivy.Module):\n",
        "    def __init__(self, h_w = (32, 32), input_channels = 3,  output_channels = 512, kernel_size = [3, 3], num_classes = 2, data_format = \"NCHW\", device = \"cpu\"):\n",
        "        self.extractor = ivy.Sequential(\n",
        "            ivy.Conv2D(input_channels, 6, [5, 5], 1,  \"SAME\", data_format = data_format),\n",
        "            ivy.GELU(),\n",
        "            ivy.Conv2D(6,  16,  [5, 5], 1,  \"SAME\", data_format = data_format),\n",
        "            ivy.GELU(),\n",
        "            ivy.Conv2D(16, output_channels, [5, 5],  1,  \"SAME\", data_format = data_format),\n",
        "            ivy.GELU()\n",
        "        )\n",
        "        \n",
        "        self.classifier = ivy.Sequential(\n",
        "            ivy.Linear(h_w[0]*h_w[1]*output_channels, 512), #since padding is same, this would be image_height x image_widht x output_channels\n",
        "            ivy.GELU(),\n",
        "            ivy.Linear(512, num_classes)\n",
        "        )\n",
        "        ivy.Module.__init__(self)\n",
        "\n",
        "    def _forward(self, x):\n",
        "        x = self.extractor(x)\n",
        "        x = ivy.flatten(x, start_dim = 1, end_dim = -1) #flatten all dims except batch dim\n",
        "        logits = self.classifier(x)\n",
        "        probs = ivy.softmax(logits)\n",
        "        return logits, probs\n",
        "\n",
        "# train the model on gpu if it's available\n",
        "device = \"cuda:0\" if ivy.gpu_is_available() else \"cpu\"\n",
        "\n",
        "model = IvyNet(h_w = (28, 28), input_channels = 1, output_channels = 120, kernel_size = [5,5], num_classes = num_classes, device = device)\n",
        "model_name = type(model).__name__.lower()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 51,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "eAn76_ynseYq",
        "outputId": "f56cea6c-2d42-4931-a405-926c61206823"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "cuda:0 ivynet\n"
          ]
        }
      ],
      "source": [
        "print(device, model_name)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "TE-jMYkehQca"
      },
      "source": [
        "# Training Loop with utility functions\n",
        "\n",
        "The `train` function is where we do the heavy lifting, and use the `loss_fn` to compute the gradients. `num_correct` is used for returning the correct set of predictions."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "aktlI5JshJb2"
      },
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": 63,
      "metadata": {
        "id": "N3BnvAx1hERH"
      },
      "outputs": [],
      "source": [
        "def num_correct(preds, labels):\n",
        "    return (preds.argmax() == labels).sum().to_numpy().item()\n",
        "\n",
        "def loss_fn(params):\n",
        "    v, model, x, y = params\n",
        "    y_pred, probs = model(x)\n",
        "    return ivy.cross_entropy(y, probs), probs\n",
        "\n",
        "def train(images, classes, epochs, model, device, num_classes = 10, batch_size = 32):\n",
        "    # training metrics\n",
        "    epoch_loss = 0.0\n",
        "    running_loss = 0.0\n",
        "    fields = ['epoch', 'epoch_loss', 'training_accuracy']\n",
        "    metrics = []\n",
        "    dataset_size = len(images)\n",
        "    \n",
        "    for epoch in range(epochs):\n",
        "        train_loss, train_correct = 0, 0\n",
        "        train_loop = tqdm(generate_batches(images, classes, len(images), batch_size = batch_size), total = dataset_size//batch_size\n",
        "        , position = 0, leave = True)\n",
        "        \n",
        "        for xbatch, ybatch in train_loop:\n",
        "            print(xbatch.shape)\n",
        "            print(ybatch.shape)\n",
        "            if device != \"cpu\":\n",
        "                 xbatch, ybatch = xbatch.to_device(\"gpu:0\"), ybatch.to_device(\"gpu:0\")\n",
        "\n",
        "            # since the cross entropy function expects the target classes to be in one-hot encoded format\n",
        "            ybatch_encoded = ivy.one_hot(ybatch, num_classes)\n",
        "            \n",
        "            # update model params\n",
        "            loss_probs, grads = ivy.execute_with_gradients(loss_fn, (model.v, model, xbatch, ybatch_encoded), ret_grad_idxs = [[0]], xs_grad_idxs = [[0]])\n",
        "            model.v = optimizer.step(model.v, grads['0'])\n",
        "            \n",
        "            batch_loss = ivy.to_numpy(loss_probs[0]).mean().item() # batch mean loss\n",
        "            epoch_loss +=  batch_loss * xbatch.shape[0]\n",
        "            train_correct += num_correct(loss_probs[1], ybatch)\n",
        "\n",
        "            train_loop.set_description(f'Epoch [{epoch+1:2d}/{epochs}]')\n",
        "            train_loop.set_postfix(\n",
        "                running_loss=batch_loss, accuracy_percentage=(train_correct/dataset_size)*100\n",
        "            )\n",
        "        epoch_loss = epoch_loss/dataset_size\n",
        "        training_accuracy = train_correct/dataset_size\n",
        "\n",
        "      \n",
        "        metrics.append([epoch, epoch_loss, training_accuracy])\n",
        "\n",
        "        train_loop.write(\n",
        "                f'\\nAverage training loss: {epoch_loss:.6f}, Train Correct: {train_correct}', end='\\n'\n",
        "            )\n",
        "\n",
        "    # write metrics for plotting\n",
        "    with open(f'/{model_name}_train_summary.csv', 'w') as f:\n",
        "        f = csv.writer(f)\n",
        "        f.writerow(fields)\n",
        "        f.writerows(metrics)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "4QnGBCrZUnhl"
      },
      "outputs": [
      {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Epoch [ 1/20]: : 157it [01:16,  2.06it/s, accuracy_percentage=0.2, running_loss=0.29]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Average training loss: 0.475401, Train Correct: 20\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Epoch [ 2/20]: : 157it [01:14,  2.11it/s, accuracy_percentage=0.14, running_loss=0.12]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Average training loss: 0.081436, Train Correct: 14\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Epoch [ 3/20]: : 157it [01:13,  2.13it/s, accuracy_percentage=0.19, running_loss=0.0187]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Average training loss: 0.029279, Train Correct: 19\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Epoch [ 4/20]: : 157it [01:14,  2.11it/s, accuracy_percentage=0.36, running_loss=0.0324]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Average training loss: 0.008382, Train Correct: 36\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Epoch [ 5/20]: : 157it [01:15,  2.07it/s, accuracy_percentage=0.6, running_loss=0.00456]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Average training loss: 0.003816, Train Correct: 60\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Epoch [ 6/20]: : 157it [01:26,  1.82it/s, accuracy_percentage=0.6, running_loss=0.00277]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Average training loss: 0.002179, Train Correct: 60\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Epoch [ 7/20]: : 157it [01:16,  2.05it/s, accuracy_percentage=0.81, running_loss=0.00175]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Average training loss: 0.001569, Train Correct: 81\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Epoch [ 8/20]: : 157it [01:14,  2.11it/s, accuracy_percentage=0.81, running_loss=0.00147]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Average training loss: 0.001235, Train Correct: 81\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Epoch [ 9/20]: : 157it [01:14,  2.09it/s, accuracy_percentage=1.06, running_loss=0.00128]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Average training loss: 0.001005, Train Correct: 106\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Epoch [10/20]: : 157it [01:14,  2.10it/s, accuracy_percentage=1.29, running_loss=0.00112]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Average training loss: 0.000837, Train Correct: 129\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Epoch [11/20]: : 157it [01:13,  2.12it/s, accuracy_percentage=1.45, running_loss=0.000989]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Average training loss: 0.000709, Train Correct: 145\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Epoch [12/20]: : 157it [01:15,  2.07it/s, accuracy_percentage=1.68, running_loss=0.000873]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Average training loss: 0.000606, Train Correct: 168\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Epoch [13/20]: : 157it [01:15,  2.08it/s, accuracy_percentage=1.77, running_loss=0.000774]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Average training loss: 0.000524, Train Correct: 177\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Epoch [14/20]: : 157it [01:15,  2.09it/s, accuracy_percentage=1.92, running_loss=0.000688]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Average training loss: 0.000455, Train Correct: 192\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Epoch [15/20]: : 157it [01:13,  2.13it/s, accuracy_percentage=1.92, running_loss=0.000613]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Average training loss: 0.000398, Train Correct: 192\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Epoch [16/20]: : 157it [01:13,  2.12it/s, accuracy_percentage=2.05, running_loss=0.000547]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Average training loss: 0.000350, Train Correct: 205\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Epoch [17/20]: : 157it [01:13,  2.13it/s, accuracy_percentage=2.18, running_loss=0.000488]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Average training loss: 0.000308, Train Correct: 218\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Epoch [18/20]: : 157it [01:13,  2.13it/s, accuracy_percentage=2.25, running_loss=0.000437]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Average training loss: 0.000273, Train Correct: 225\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Epoch [19/20]: : 157it [01:14,  2.10it/s, accuracy_percentage=2.38, running_loss=0.000391]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Average training loss: 0.000243, Train Correct: 238\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Epoch [20/20]: : 157it [01:19,  1.98it/s, accuracy_percentage=2.6, running_loss=0.000351]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Average training loss: 0.000216, Train Correct: 260\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\n"
     ]
    }
   ],
      "source": [
        "train(images, classes, num_epochs, model, device, num_classes = num_classes, batch_size = batch_size)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "vf0SzHX2iG7-"
      },
      "source": [
        "# Plotting the training metrics\n",
        " "
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 297
        },
        "id": "2AsYxL4Bh6WO",
        "outputId": "f37fd882-94c1-4be6-9c86-de42a0b1140d"
      },
      "outputs": [
        {
          "data": {
            "image/png": "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F7EDgYGBXHPNNQwePJimTZsyf/580tLSACzJbF5eHoDl+baK5OvrS3p6OoWFhQBXPGttnTp1SEtLs/zicfjwYct+k8nEyJEjWbduHZ9++imtWrVi6tSp5OTkEBISwnvvvce6det47bXXOHr0KG+99Vb5NE5ERKQMKktfnZeXx5o1a+jVqxfvvPMO77zzDlOmTKGgoMAyzL127dol2vDll1+ycuVKateuDfzdvpycHJYsWcLmzZst34MzyXZp34OzR7999dVXrFixggEDBvDpp5/SsWNHS5m/vz+FhYWW7++6detYunQphYWFNG3alCZNmrBmzRp+++03brjhBg1vl0pFCbqIHTGZTIwYMYKTJ09aJkC56qqrAFi8eDErV67kjz/+qPC4OnToQHZ2Nq+++irffPON5dmvC8nMzGTevHkl/iUlJXH77bdz8uRJpk+fzi+//MK7776Lr68v119/PR9++CFt2rThu+++Iz8/Hy8vL9zc3HBxcaF///4MHjyYnTt34uHhgaurKx4eHhXTeBERkbM4el+9Zs0acnJy6NevH927d6d79+7cfffdBAYGsnLlSgBuuukm9u7dy6JFi/j0008ZO3Ys8fHx1KtXj5YtW/Ltt9/y448/Mnv2bCZNmsTJkyepX78+zs7OrFq1ik2bNrFkyZKLxnsmkXd1dWX//v0kJCQA8Ntvv1mGrM+cOZM1a9bw3HPP8fXXX1tGDtx6662sWbOGgwcP0qdPn/L49onYDSXoInamZ8+ehIeHEx0dzV9//cXdd99N586d+eSTT/jiiy+48847Kzymhx56iE6dOvHBBx/w8ccfc8sttwBc8DnwtLQ0ZsyYUeLf/v37uf322xk9ejQrV67kiSeewMvLi/nz5+Pt7c0dd9zBzTffzKRJk/jXv/5FQkICr732Gm5ubrzwwgsYhsGjjz7KqFGjaNOmDc8880xFfgtEREQsHLmvXrlyJS4uLiXuWANERkZaZnMfPnw4/fv355133uE///kP99xzD0888QRQ/Cx+ixYtGDNmDD/99BMvvvgiXbp0oXbt2pZH0saOHcsdd9xx0Xhvu+02IiIiWLhwId999x3//e9/8fX15T//+Q/dunVj3LhxbNy4kaeffpomTZowa9Ysy7k333wz+fn5+Pj40Llz5/L49onYDZNhGIatgxAR+1ZUVMThw4cJDAzE1dWVSZMmsWTJEn788UdCQkJsHZ6IiEiVV5X66hMnThAZGcmtt97K1KlTbR2OSLnSHXQRuaQlS5Zwww03MHv2bP73v/+xcuVKrrrqKurVq2fr0ERERISq01f//PPPvPTSS5jNZqKiomwdjki50x10Ebkks9nMtGnT+Pbbb8nLy+Oaa67hpZdeonHjxrYOTURERKg6ffXNN99McnIyw4YN44EHHrB1OCLlTgm6iIiIiIiIiB3QEHcRERERERERO2DXiwbGxsbaOgQRERGbatOmja1DKHfq30VERErv4+06QYfy/cUkPj6esLCwcqvPXqhdjkXtcixql2OpbO2qzIms+vdLU7sci9rlWNQux1IZ23WhPl5D3EVERERERETsgBJ0ERERERERETugBF1ERERERETEDihBFxEREREREbEDStBFRERERERE7IASdBERERERERE7oARdRERERERExA5UmQS9sMggt6DI1mGIiIiIiIiIgygsMsjJN1fY9apMgv7er/sZ9nWSrcMQEZFy9sorrxAVFcWNN97I0KFDiYqKYvjw4WU69+mnnyYvL++SxyUlJXHnnXf+01DFjp39OerWrZtVPkdn3HjjjUyZMuVKQxURkQqSmJbDjf/9hceX/FFh13SpsCvZmAk4kmXmRF4BNdxdbR2OiIiUk7FjxwKwfPly1q1bx4wZM8p87quvvmqtsMTBnP052rNnD2PGjCnzuZfzOdqxYweGYbBq1Sqef/55nJyqzL0SERGHsulgGo8sjqWwyGByvxYVdt0qk6CH+HkCxX8FCQ/ysXE0IiJibWPHjsXV1ZWMjAymTZvGs88+S05ODnl5ebz00ku0bNmSHj168PXXXzNp0iQCAgKIi4vj8OHDzJo1i/Dw8Ete488//+Tf//43Tk5OVK9enVdeeQVnZ2dGjhxJfn4++fn5jB8/nvr165+3ryz1i+2V9+doxYoV3HPPPfz4449s2LCBjh07AjB58mS2bduGs7MzL7/8Mk2aNOH9998nMTHRsi89PZ2lS5fy+uuvA9ChQwfWr19PVFQUjRs3BuCRRx7hueeeA8BsNjN9+nTq16/PF198weLFi3FycuLBBx8kIyOD5ORkRo4cCcCDDz7ImDFjaNasWQV9Z0VE7Nfnm5MYs2w79Xw9mP9AOxrWrl5h1646CbrvmQQ9Vwm6iIiVfBabxCebEsu1znvb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unXrVqK8e/fuRnZ2tg0iu3Lr1q0znnzyyQuWO+p7dbb169cbEydOLLGvffv2Normypw8edIYPHiw8eKLLxqLFy82DMMwxo4da3z77beGYRjGf/7zH2Pp0qUlzrnUz6E9KK1do0ePNr755hvDMAxjyZIlxvTp00ucc6nPrD0orV1jxowx/ve//13wHEd9v842duxYY+vWrSX2ffbZZ8Yrr7xSUSGKlal/dyzq4+2f+ve/qX+3HfXvJVXKIe4xMTH07NkTgNDQUDIzM8nOzgYgMTERHx8f6tati5OTE926dSMmJsaW4ZZZu3bteO211wCoUaMGubm5FBYW2jgq63Hk9+psb775Jk888YStw/hH3NzceO+99wgICLDsW79+PTfccAMA3bt3P++9udjPob0orV0TJkygT58+APj6+pKRkWGj6K5cae26FEd9v87Yv38/WVlZdnlXQMqP+vfKw5Hfr7M5eh+v/t2xqH+vGiplgp6amoqvr69l28/Pj5SUFABSUlLw8/MrtczeOTs74+npCcCyZcvo2rXreUOmJkyYwMCBA5k1axaGg6ygt3fvXh577DEGDhzI77//btnvyO/VGdu2baNu3bolhlAB5Ofn8+yzzzJgwAAWLFhgo+jKzsXFBXd39xL7cnNzLUPeatWqdd57c7GfQ3tRWrs8PT1xdnamsLCQDz/8kFtvvfW88y70mbUXpbULYMmSJQwZMoSnn36atLS0EmWO+n6dsWjRIgYPHlxq2YYNGxg6dCj3338/O3futGaIYmXq3x2rfwf18fbex6t/L0n9u22ofy+p0j6DfjZH6sjK4scff2TZsmXMnz+/xP4RI0Zw3XXX4ePjw7Bhw1i1ahU33nijjaIsm6uuuorhw4dz0003kZiYyJAhQ/j+++/Pe9bJUS1btow77rjjvP2jR4/mtttuw2QyMXjwYNq2bcs111xjgwjLR1l+xhzp57CwsJDRo0fTsWNHOnXqVKLMUT+zt99+OzVr1iQsLIy5c+fyxhtvMH78+Ase70jvV35+PrGxsUycOPG8slatWuHn58f111/P5s2bGTNmDF9//XXFBylW4Uif07KoTP07OO7/l2VVFfp49e/2/3lV/175+vdKeQc9ICCA1NRUy3ZycrLlr5vnlh07duyyhonY2q+//so777zDe++9h7e3d4myfv36UatWLVxcXOjatSu7d++2UZRlFxgYSN++fTGZTNSvX5/atWtz7NgxwPHfKygeJnbttdeet3/gwIFUr14dT09POnbs6BDv1bk8PT3Jy8sDSn9vLvZzaO+ef/55GjRowPDhw88ru9hn1p516tSJsLAwoHjCqXM/c478fm3cuPGCQ99CQ0Mtk+Vce+21pKWlVfqhw5WZ+nfH6d9Bfbyj9vHq39W/24uq2r9XygQ9MjKSVatWARAXF0dAQABeXl4ABAcHk52dTVJSEmazmdWrVxMZGWnLcMssKyuLGTNm8O6771pmajy7bOjQoeTn5wPFH+gzs1Das6+++op58+YBxcPdjh8/bpmZ1pHfKyju1KpXr37eX17379/Ps88+i2EYmM1m/vjjD4d4r87VuXNny8/Z999/z3XXXVei/GI/h/bsq6++wtXVlREjRlyw/EKfWXv25JNPkpiYCBT/UnnuZ85R3y+A7du306xZs1LL3nvvPVasWAEUzxDr5+dn17Mpy8Wpf3ec/h3UxztqH6/+Xf27vaiq/bvJcKRxDpdh1qxZbNq0CZPJxIQJE9i5cyfe3t706tWLjRs3MmvWLAB69+7N0KFDbRxt2URHRzNnzhwaNmxo2dehQweaNm1Kr169WLhwIV988QXVqlWjefPmvPTSS5hMJhtGfGnZ2dmMGjWKEydOUFBQwPDhwzl+/LjDv1dQvOzKf//7X95//30A5s6dS7t27bj22muZOXMm69atw8nJiR49etj9shA7duxg+vTpHDp0CBcXFwIDA5k1axZjx47l1KlTBAUFMW3aNFxdXXn66aeZNm0a7u7u5/0cXug/WVsprV3Hjx+nWrVqls4rNDSUiRMnWtplNpvP+8x269bNxi0pqbR2DR48mLlz5+Lh4YGnpyfTpk2jVq1aDv9+zZkzhzlz5tCmTRv69u1rOfbxxx/n7bff5ujRozz33HOWX5btdXkZKTv1747Rv4P6eEfo49W/q3+3B+rfS6q0CbqIiIiIiIiII6mUQ9xFREREREREHI0SdBERERERERE7oARdRERERERExA4oQRcRERERERGxA0rQRUREREREROyAi60DEBHrSUpK4tZbb6VFixYl9s+ZM+e8tXYvx5w5c/D19WXw4MH/MEIRERG5XOrfRSovJegilVzDhg1ZvHixrcMQERGRcqT+XaRyUoIuUgWNHTsWT09P9u/fT3p6OtOmTaN58+YsXLiQb7/9FoAbbriBRx55hEOHDjF27FgKCwsJCgpi+vTpAOzevZtHH32UgwcP8sILL9C1a1cmT57Mjh07KCwsZODAgdx55522bKaIiEiVov5dxPHpGXSRKspsNvPBBx/w1FNP8eabb5KYmMjnn3/O0qVLWbp0Kd999x1//fUXr776Kg888AAffvghAQEB7NixA4CMjAzeffddXnzxRT7++GMyMjJYs2YNH3/8MR9++CFms9nGLRQREal61L+LODbdQRep5A4cOEBUVJRlu2HDhgB07twZgNatWzNr1izi4+Np1aoVLi7F/y1ERESwa9cudu7cyQsvvADA6NGjAfjll1+IiIgAIDAwkKysLGrWrMlVV13F448/zo033ki/fv0qqokiIiJVjvp3kcpJCbpIJVfaM2pjx46lqKjIsm0ymTCZTBiGYdlXUFCAk5MTzs7OJfafcaajP9v7779PXFwcK1as4Msvv2T+/Pnl2BIRERE5Q/27SOWkIe4iVVRsbCwAmzdvJjQ0lLCwMLZs2YLZbMZsNrN161bCwsJo0aIF69atA+C1115j7dq1pdaXlJTEokWLCA8PZ8yYMWRkZFRUU0REROQ09e8ijk130EUquXOHwAG4u7vj4uLCo48+ypEjR5g5cybBwcH079+fwYMHYxgG99xzD/Xq1WPEiBE8//zzfPjhh9StW5fhw4dbOv+zBQQEsHnzZr799ltcXV256667KqqJIiIiVY76d5HKyWSUNrZFRCq1sWPH0qdPH7p3727rUERERKScqH8XcXwa4i4iIiIiIiJiB3QHXURERERERMQO6A66iIiIiIiIiB1Qgi4iIiIiIiJiB5Sgi4iIiIiIiNgBJegiIiIiIiIidkAJuoiIiIiIiIgd+D8+RqP7A9C5ZwAAAABJRU5ErkJggg==",
            "text/plain": [
              "<Figure size 1008x288 with 2 Axes>"
            ]
          },
          "metadata": {},
          "output_type": "display_data"
        }
      ],
      "source": [
        "def plot_summary(path):\n",
        "    data = pd.read_csv(path)\n",
        "\n",
        "    plt.style.use('seaborn-whitegrid')\n",
        "    fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(14, 4))\n",
        "\n",
        "    ax1.plot(data['epoch'], data['epoch_loss'], label='Train Loss')\n",
        "    ax2.plot(data['epoch'], data['training_accuracy'], label='Train Accuracy')\n",
        "\n",
        "    ax1.legend()\n",
        "    ax1.set_title('Running Loss', fontweight='bold')\n",
        "    ax1.set_xlabel('Epochs')\n",
        "    ax1.set_ylabel('Loss')\n",
        "    ax1.grid(True)\n",
        "\n",
        "    ax2.legend()\n",
        "    ax2.set_title('Running Accuracy', fontweight='bold')\n",
        "    ax2.set_xlabel('Epochs')\n",
        "    ax2.set_ylabel('Accuracy')\n",
        "    ax2.grid(True)\n",
        "\n",
        "    plt.tight_layout()\n",
        "    fig.savefig(f'summary_plots.png')\n",
        "    plt.show()\n",
        "    plt.close()\n",
        "\n",
        "\n",
        "plot_summary(f'/{model_name}_train_summary.csv')"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "Wxnb0QRBh3UB",
        "pycharm": {
          "name": "#%% md\n"
        }
      },
      "source": [
        "# Save the trained Model"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "yf49uvhL30H1"
      },
      "outputs": [],
      "source": [
        "model.save_weights('model_params/ivynet_weights.hdf5')"
      ]
    }
  ],
  "metadata": {
    "accelerator": "GPU",
    "colab": {
      "provenance": []
    },
    "gpuClass": "standard",
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}
